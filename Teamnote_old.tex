\documentclass[landscape,8pt]{article}
\linespread{1}
\usepackage{multicol}
\setlength{\columnsep}{0.5cm}
\setlength{\columnseprule}{0.25pt}
\usepackage{amsmath}
\usepackage{graphbox}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{geometry}
\geometry{a4paper, landscape, margin = 0.6in}
\usepackage{enumerate}
\usepackage{amsthm}
\usepackage{physics}
\usepackage{float}
\usepackage{kotex}
\usepackage{tabu}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{authblk}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[R]{Gratus907 (Wonseok Shin)}
\fancyhead[L]{Seoul National University}
\usepackage[compact]{titlesec}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\newcommand{\st}{\text{ such that }}
\newcommand{\for}{\text{ for }}
\newcommand{\newpara}[1]{\paragraph{#1} \mbox{}\\}
\everymath{\displaystyle}
\setlength{\parskip}{0pt}
\setlength{\parsep}{-2pt}
\setlength{\parindent}{0pt}
\titlespacing{\section}{0pt}{*0}{*0}
\titlespacing{\subsection}{0pt}{*1}{*0.5}
\titlespacing{\subsubsection}{0pt}{*0}{*0}
\topsep=5pt \partopsep=5pt
\setlength{\headheight}{12pt}
\setlength{\headsep}{8pt}
\setlength{\topmargin}{-65pt}
\title{\Huge{\textsf{Little Piplup}}}
\author{Gratus907(Wonseok Shin), Coffeetea(Jinje Han), DHdroid(Donghyun Son)}
\date{ }

\begin{document}

{
  \vspace*{0.5in}
  \setlength{\columnseprule}{0pt}
  \begin{multicols}{3}\raggedcolumns
  \vspace*{\fill}
  \begin{figure}[H]
  \includegraphics[width=\linewidth]{piplup}
  \end{figure}
  \vspace*{\fill}
  \columnbreak
  \begin{center}
  \vspace*{\fill}
  \huge{\textbf{Little Piplup}\\}
  \vspace{2em}
    \LARGE{Contest Teamnote \\}
   \large{UCPC 2020 Preliminary ver}
  \vspace*{\fill}
  \end{center}
  \columnbreak

  \vspace*{\fill}
  \begin{figure}[H]
  \includegraphics[width=\linewidth]{revplup}
  \end{figure}

  \vspace*{\fill}
  \end{multicols}
}

\begin{comment}
{


% Personal Cover Page
\vspace*{0.5in}
\setlength{\columnseprule}{0pt}
\begin{multicols}{3}\raggedcolumns
\vspace*{\fill}
\begin{figure}[H]
%\includegraphics[width=\linewidth]{piplup}
\end{figure}
\vspace*{\fill}
\columnbreak
\begin{center}
\vspace*{\fill}
\huge{\textbf{Algorithm Note}\\}
\vspace{2em}
  \LARGE{Wonseok Shin \\}
 \large{2020 Google Codejam Round 2 Ver.}
\vspace*{\fill}
\end{center}
\columnbreak

\vspace*{\fill}

\vspace*{\fill}
\end{multicols}
\begin{figure}[H]
%\includegraphics[width=\linewidth]{revplup}
\end{figure}
}
\end{comment}


\newpage
\begin{multicols}{2}\raggedcolumns
\tableofcontents
\pagebreak
\end{multicols}
\begin{multicols}{2}\raggedcolumns


\section{Settings}
  \subsection{C++}
    \verbatiminput{./code/Header.cpp}

\section{Data Structures}
  \subsection{Segment Tree - Range Minimum}
  query(a, b) : $[a, b]$ minimum element\\
  update(p, x) : add $x$ to index $p$
     \verbatiminput{./code/Data_Structures/Range_Minimum_Query.cpp}
  \pagebreak
  \subsection{Segment Tree Lazy Propagation}
  range\_upd(s, e, k) : add $k$ to $[s, e]$\\
  sum(s, e) : $[s, e]$ summation
     \verbatiminput{./code/Data_Structures/Segment_Tree_Lazy.cpp}
  \pagebreak
  \subsection{2D Segment Tree}
    \verbatiminput{./code/Data_Structures/2D_Seg.cpp}

  \subsection{Fenwick Tree}
    \verbatiminput{./code/Data_Structures/Fenwick_Tree.cpp}

  \subsection{Disjoint Set Union (Union - Find)}
    \verbatiminput{./code/Data_Structures/Disjoint_Set_Union.cpp}

\section{Mathematics}
  \subsection{Useful Mathematical Formula}
    \begin{itemize}
      \item Catalan Number : Number of valid parantheses strings with $n$ pairs
      \[
        C_n = \frac{1}{n+1}\binom{2n}{n}
      \]
      \item Nim Game : Remember - XOR of all piles.
      \item Lucas Formula : $\binom{n}{m} \mod p = \prod \binom{n_i}{m_i} \mod p$
      \item Sum of divisors of $n$ : About $n \log \log n$.
      \item 어떤 수열을 $n$개의 증가하는 수열로 덮을 수 있다 $\leftrightarrow$ longest decreasing subsequence 의 길이가 $n$보다 작거나 같다. (Dilworth's Theorem)
    \end{itemize}
  \subsection{Binomial Coefficient}
    If faster method is needed : use modulo inverse
    \verbatiminput{./code/Mathematics/Binomial.cpp}
  \subsection{Extended Euclidean Algorithm}
    $(x, y)$ such that $ax + by = \gcd(a, b) = d$.
    \verbatiminput{./code/Mathematics/Extended_Euclidean_Algorithm.cpp}

  \subsection{Fast Modulo Exponentiation}
  Calculating \texttt{$x^y$ mod $p$} in $\order{\log y}$ time.
    \verbatiminput{./code/Mathematics/Fast_Modulo_Exponentiation.cpp}

  \subsection{Modular Multiplicative Inverse}
    \verbatiminput{./code/Mathematics/Modular_Inverse.cpp}

  \subsection{Miller-Rabin Primality Testing}
  Base values of $a$ chosen so that results are tested to be correct up to $10^{14}$.
    \verbatiminput{./code/Mathematics/Miller_Rabin_Test.cpp}

  \subsection{Pollard-Rho Factorization}
    \verbatiminput{./code/Mathematics/Pollard_Rho_Algorithm.cpp}

  \subsection{Euler Totient}
  Calculating number of integers below $n$ which is coprime with $n$.
    \verbatiminput{./code/Mathematics/Euler_Phi_Function.cpp}


  \subsection{Fast Fourier Transform}
    Compute $A(x) * B(x)$ in $O(n\log n)$ time.\\
    Convolution 빠르게 구하기 \[ c_j = \sum_{i = 0}^{j} a_i b_{j-i}\]
    \verbatiminput{./code/Mathematics/Fast_Fourier_Transform.cpp}
  \subsection{Berlekamp-Massey Algorithm}
    초항 $3k$ 개로 $k*k$ 행렬 전이를 갖는 문제를 선형점화식으로 변환 + Kitamasa method를 이용한 $k^2 \log n$ 시간 계산. 초항만 몇개 구하고 \texttt{guess\_nth\_term} 쓰면 ok. 점화식을 알때는 \texttt{get\_nth}로 키타마사만 쓰기.\\
    Todo : FFT를 적용한 $k \log k \log n$ 키타마사 구현하기.
    \verbatiminput{./code/Mathematics/Berlekamp_Massey.cpp}
\section{Geometry}
  \subsection{CCW}
    \verbatiminput{./code/Geometry/CCW.cpp}

  \subsection{Point in polygon}
    Returns boolean, if point is in the polygon (represented as vector of points).
    \verbatiminput{./code/Geometry/Point_in_polygon.cpp}
  \subsection{Length of Segment Union}
    Length of segment union, from vector of \{start, end\}.
    \verbatiminput{./code/Geometry/Length_of_Segment_Union.cpp}
  \subsection{Closest Pair Problem}
    Requires : Points must be sorted with x-axis.\\
    Runs in $\mathcal{O}(n \log^2 n)$
    \verbatiminput{./code/Geometry/Closest_pair.cpp}
  \subsection{Graham Scan + Rotating Calipers}
    \verbatiminput{./code/Geometry/Graham_scan_Rot_cal.cpp}

  \subsection{Intersection of Line Segment}
    \verbatiminput{./code/Geometry/Line_Segment_Intersection.cpp}

\section{Graphs}
  \subsection{Topological Sorting}
  Topological sorting with dfs
    \verbatiminput{./code/Graph/Topological_Sort.cpp}

  \subsection{Lowest Common Ancestor}
  LCA Algorithm by sparse table.\\
  minlen : $(x, y)$ 사이를 잇는 간선 중 최소 길이 간선.\\
  maxlen : $(x, y)$ 사이를 잇는 간선 중 최대 길이 간선.
    \verbatiminput{./code/Graph/Lowest_Common_Ancestor.cpp}

  \subsection{MST Kruskal Algorithm}
  Based on Union-Find implementation\\
  $\order{E \log E}$ if path-compressed Union Find.
    \verbatiminput{./code/Graph/Kruskal_MST.cpp}

  \subsection{MST Prim Algorithm}
    \verbatiminput{./code/Graph/Prim_MST.cpp}

  \subsection{Dinic's Algorithm}
    \verbatiminput{./code/Graph/Dinic.cpp}

  \subsection{Cosaraju SCC Algorithm}
    \verbatiminput{./code/Graph/Cosaraju_Algorithm.cpp}

 \subsection{MCMF}
    \verbatiminput{./code/Graph/MinCostMaxFlow.cpp}
  %\subsection{Heavy-Light Decomposition}

  %\subsection{Centroid Decomposition}

  %\subsection{Hungarian Algorithm}
    %$\order{n^3}$ assignment problem

\section{Shortest Path}
  모든 간선의 가중치를 필요할 때마다 0으로 잘 초기화했는지 확인하기.
  \subsection{Dijkstra}
    $\order{E \log V}$ Single-Start-Shortest-Path.\\
    가중치에 음수 없는거 항상 확인하고 쓰기.
      \verbatiminput{./code/Graph/Dijkstra_Algorithm.cpp}

  \subsection{Bellman Ford}
    $\order{EV}$ Single-Start-Shortest-Path.\\
    Not working for graph with minus cycle $\rightarrow$ must detect.
      \verbatiminput{./code/Graph/Bellman_Ford_Algorithm.cpp}

  \subsection{SPFA Algorithm}
    Average $\order{E}$, worst $\order{VE}$.
    \verbatiminput{./code/Graph/SPFA.cpp}

  \subsection{Floyd-Warshall}
    Works on adjacency matrix, in $\order{V^3}$.
      \verbatiminput{./code/Graph/Floyd_Warshall_Algorithm.cpp}


\section{Dynamic}
  \subsection{DP optimization Technique}
  \subsubsection{Convex Hull Trick}
    dp[i] = $\min_{j < i}$ (dp[j] + a[i]b[j]) 이고, $b$가 단조 감소하며, (현재 구현 기준) $a$가 단조 증가할 때, 직선 \texttt{y = b[j]*x + dp[j]}들을 기준으로 해석해서 시간 복잡도를 줄인다.
    \verbatiminput{./code/Dynamic_Programming/Convex_Hull_Trick.cpp}
  \subsubsection{Li Chao Tree}
    \verbatiminput{./code/Dynamic_Programming/LiChao_Tree.cpp}
  \subsubsection{Knuth Optimization}
    dp 점화식이 다음 조건을 만족할 때, $O(n^3)$ 을 $O(n^2)$ 로 줄인다.
    \begin{itemize}
      \item dp[i][j] = $\min_{i < k < j}$(dp[i][k] + dp[k][j]) + C[i][j]
      \item C[a][c] + C[b][d] $\leq$ C[a][d] + C[b][c] $\leq$ 2C[a][d] when $a \leq b \leq c \leq d$.
    \end{itemize}
    이때, dp[i][j]가 최소가 되는 $k$는 $k_{(i, j-1)} \leq k_{(i, j)} \leq k_{(i+1, j)}$ 를 만족한다.
      \verbatiminput{./code/Dynamic_Programming/Knuth_opt.cpp}
  \subsection{Longest Increasing Subsequence}
    Find LIS in $\order{n \log n}$ time.
      \verbatiminput{./code/Dynamic_Programming/Longest_Increasing_Subsequence.cpp}
    Using multiset...
      \verbatiminput{./code/Dynamic_Programming/Multiset_Shorter_LIS.cpp}
  \subsection{Largest Sum Subarray}
    Computes sum of largest sum subarray in $\order{N}$
      \verbatiminput{./code/Dynamic_Programming/Largest_Maximum_Subarray.cpp}

  \subsection{0-1 Knapsack}
    \verbatiminput{./code/Dynamic_Programming/0-1_Knapsack.cpp}\

  \subsection{Longest Common Subsequence}
    \verbatiminput{./code/Dynamic_Programming/Longest_Common_Substring.cpp}

  \subsection{Edit Distance}
    \verbatiminput{./code/Dynamic_Programming/Edit_Distance.cpp}

\section{String}
  \subsection{KMP Algorithm}
    Pi 배열의 정의 : $str[0]$ 부터 $str[i]$ 까지 중 접두사가 접미사와 같은 부분만큼의 길이.
    \verbatiminput{./code/String/KMP.cpp}
  \subsection{Manacher's Algorithm}
    A[i] = $i$ 번을 중심으로 하는 가장 긴 팰린드롬이 되는 반지름.
    \verbatiminput{./code/String/Manacher.cpp}
  \subsection{Trie}
    \verbatiminput{./code/String/Trie.cpp}
  \subsection{Rabin-Karp Hashing}
    Hashmap[$k$]에, 길이가 len인 부분 문자열의 해시값이 $k$ 가 되는 시작점 인덱스 $i$ 를 push.
    \verbatiminput{./code/String/Rabin-Karp.cpp}
  %\subsection{Aho-Corasick Algorithm}
\columnbreak

\section{Miscellaneous}
  \subsection{Binary and Ternary Search}
    Preventing stupid mistakes by writing garbage instead of proper binary search.\\
    상황에 따라 lo와 hi 중 어느 쪽이 답인지 달라짐.
    \verbatiminput{./code/Misc/Binary_Search.cpp}
    Ternary search
    \verbatiminput{./code/Misc/Ternary_search.cpp}
  \subsection{GCC Order Statistics Tree}
    \verbatiminput{./code/Misc/Pbds_OST.cpp}
  \subsection{Useful Bitwise Functions in C++}
  \begin{verbatim}
    int __builtin_clz(int x);// number of leading zero
    int __builtin_ctz(int x);// number of trailing zero
    int __builtin_clzll(ll x);// number of leading zero
    int __builtin_ctzll(ll x);// number of trailing zero
    int __builtin_popcount(int x);// number of 1-bits in x
    int __builtin_popcountll(ll x);// number of 1-bits in x

    lsb(n): (n & -n); // last bit (smallest)
    floor(log2(n)): 31 - __builtin_clz(n | 1);
    floor(log2(n)): 63 - __builtin_clzll(n | 1);

    // compute next perm. ex) 00111, 01011, 01101, 01110, 10011, 10101..
    ll next_perm(ll v)
    {
      ll t = v | (v-1);
      return (t + 1) | (((~t & -~t) - 1) >> (__builtin_ctz(v) + 1));
    }
  \end{verbatim}
  \pagebreak
  \subsection{Prime numbers}
  \begin{verbatim}
    < 10^k    prime   # of prime          < 10^k            prime
    -------------------------------------------------------------
    1             7            4          10           9999999967
    2            97           25          11          99999999977
    3           997          168          12         999999999989
    4          9973         1229          13        9999999999971
    5         99991         9592          14       99999999999973
    6        999983        78498          15      999999999999989
    7       9999991       664579          16     9999999999999937
    8      99999989      5761455          17    99999999999999997
    9     999999937     50847534          18   999999999999999989
  \end{verbatim}
  \subsection{Time Complexity of Algorithms}
    \begin{itemize}
      \item Map, Set : $\log n$ 삽입 삭제 탐색 , But very big constant
      \item PBDS\_OST : $\log n$ 삽입 삭제 탐색 , But very very big constant
      \item Segment Tree : $\log n$ change, $\log n$ query
      \item Lazy Propagation : $\log n$ segment addition
      \item Fenwick Tree : Same with Segtree but faster
      \item DSU : Inverse Ackermann merge
      \item GCD : $\log n$
      \item Binary Exponentiation : $\log b$
      \item Fast Fourier Transform : $n\log n$ 다항식 곱셈
      \item Closest Pair DnC : $n \log n$
      \item Graham Scan : $n \log n$
      \item Topological Sort : $n$
      \item LCA : Build time $n \log n$, 쿼리당 $\log n$
      \item Kruskal, Prim : $n\log n$
      \item Dijkstra : $E \log V$
      \item Bellman Ford : $EV$
      \item SPFA : $EV$ 이지만 매우 빠름, Expected $E$
      \item Floyd-Warshall : $V^3$
      \item Convex Hull Trick : $n^2 \to n$ or $n \log n$
      \item Knuth Opt : $n^3 \to n^2$
      \item Longest Increasing Subsequence : $n \log n$
      \item 0-1 Knapsack : $nw$
      \item Longest Common Subsequence : $n^2$
      \item Edit Distance : $n^2$
      \item KMP : $N+M$ pattern matching
      \item Manacher : $N$ palindrome finding
      \item Trie : $M$ insert, $M$ erase, $M$ search
      \item Binary, Ternary : $\log n$
    \end{itemize}

\newpage
\section{Checkpoints}
  \subsection{Debugging}
\begin{itemize}
  \item $10^5 * 10^5 \Rightarrow \text{OVERFLOW}$. 특히 for 문 안에서 \texttt{i * i < n} 할때 조심하기.
  \item If unsure with overflow, use \\
  \texttt{\#define int long long} and stop caring.
  \item 행렬과 기하의 $i, j$ 인덱스 조심. 헷갈리면 쓰면서 가기.
  \item Segment Tree, Trie, Fenwick 등 Struct 구현체 사용할 때는 항상 내부의 $n$ 이 제대로 초기화되었는지 확인하기.
  \item Testcase가 여러 개인 문제는 항상 초기화 문제를 확인하기. 입력을 다 받지 않았는데 break나 return으로 끊어버리면 안됨.
  \item iterator 주의 : .end() 는 항상 맨 끝 원소보다 하나 더 뒤의 iterator. erase쓸 때는 iterator++ 관련된 문제들에 주의해야 한다.
  \item std::sort must compare with Strict weak ordering \textcolor{red}{(Codejam 2020 1A-A)}
  \item Memory Limit : Local variable은 int 10만개 정도까지만 사용. Global Variable의 경우 128MB면 대략 int 2000만 개까지는 잘 들어간다. long long은 절반. stack, queue, map, set 같은 특이한 컨테이너는 100만개를 잡으면 메모리가 버겁지만 vector 100만개는 잡아도 된다.
  \item Array out of Bound : 배열의 길이는 충분한가? Vector resize를 했다면 그것도 충분할까? 배열의 -1번에 접근한 적은 없는게 확실할까?
  \item Binary Search : 제대로 짠 게 맞을까? 1 차이 날 때 / lo == hi 일 때 등등. Infinite loop 주의하기.
  \item Graph : 반례 유의하기. Connected라는 말이 없으면 Disconnected. Acyclic 하다는 말이 없으면 Cycle 넣기, 특히 $A \leftrightarrow B$ 그래프로 2개짜리 사이클 생각하기.
  \item Set과 map은 매우 느리다.
\end{itemize}
  \subsection{Thinking}
    \begin{itemize}
      \item 모든 경우를 다 할 수 없나? 왜 안 되지? 시간 복잡도 잘 생각해 보기. 정해의 Target Complexity를 먼저 생각하고 주요 알고리즘들의 Complexity로 짜맞추기.\\
      예를들어, 쿼리가 30만개 들어온다면 한 쿼리를 적어도 $\log{n}$ 에 처리할 방법이 아무튼 있다는 뜻.
      \item 그 방법이 뭐지? xxxx한 일을 어떤 시간복잡도에 실행하는 적절한 자료구조가 있다면?
      \begin{itemize}
        \item 필요한 게 정렬성이라면 힙이나 map을 쓸 수 있고
        \item multiset / multimap도 사용할 수 있고.. 느리지만.
      \end{itemize}
      \item 단조함수이며, 충분히 빠르게 검증가능한가 : Binary Search.
      \item 차원이 높은 문제 : 차원 내려서 생각하기. 3 $\rightarrow$ 2. 2 $\rightarrow$ 1. \textcolor{red}{2019 Codejam R1B-1 Manhattaen Crepe Cart}
      \item 이 문제가 사실 그래프 관련 문제는 아닐까?
        \begin{itemize}
          \item 만약 그렇다면, `간선' 과 `정점' 은 각각..?
          \item 간선과 정점이 몇 개 정도 있는가?
        \end{itemize}
      \item 이 문제에 Overlapping Subproblem이 보이나? \\$\rightarrow$ Dynamic Programming 을 적용.
      \item Directed Graph, 특히 Cycle에 관한 문제 : Topological Sorting? \textcolor{red}{(ex : SNUPC 2019 kdh9949)}
      \item 답의 상한이 Reasonable 하게 작은가?
      \item output이 특정 수열/OX 형태 : 작은 예제를 Exhasutive Search. 모르는 무언가를 알기 위해서는 데이터가 필요하다.
      \item 그래프 문제에서, 어떤 ``조건" 이 들어갔을 때 $\to$ 이 문제를 ``정점을 늘림으로써" 단순한 그래프 문제로 바꿀 수 있나? (ex : SNUPC 2018 달빛 여우) 이를테면, 홀짝성에 따라 점을 2배로 늘림으로써?
      \item DP도 마찬가지. 어떤 조건을 단순화하기 위해 상태의 수를 사이사이에 집어넣을 수 있나? (ex : SNUPC 2018 실버런)
      \item DP State를 어떻게 나타낼 것인가? 첫 $i$개만을 이용한 답을 알면 $i+1$개째가 들어왔을 때 빠르게 처리할 수 있을까?
      \item 더 큰 table에서 시작해서 줄여가기. 특히 Memory가 모자라다면 Toggling으로 차원 하나 내릴 수 있는 경우도 상당히 많이 있다. 각 칸의 갱신 시간과 칸의 개수 찾기.
      \item Square root Decomposition : $O(n \log n)$ 이 생각나면 좋을 것 같지만 잘 생각나지 않고, 제한을 보니 $O(n \sqrt{n})$ 이면 될것도 같이 생겼을 때 생각해 보기. $O(\sqrt{n})$ 버킷 테크닉. \textcolor{red}{Red Army 2020 : Queue}
      \item 복잡도가 맞는데 왜인지 안 뚫리면 : 필요없는 long long을 사용하지 않았나? map이나 set iterator들을 보면서 상수 커팅. 간단한 함수들을 inlining. 재귀를 반복문으로. 특히 Set과 Map은 끔찍하게 느리다.
      \item 마지막 생각 : 조금 추하지만 해싱이나 Random 또는 \texttt{bitset} 을 이용한 $n^2 / 64$ 같은걸로 뚫을 수 있나? 컴파일러를 믿고 $10^8$의 몇 배 정도까지는 내 봐도 될 수도. 의외로 Naive한 문제가 많다. \textcolor{red}{Atcoder 158 Divisible Substring}
    \end{itemize}

\end{multicols}
\end{document}
